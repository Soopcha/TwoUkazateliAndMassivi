#include <iostream>
#include <math.h>
using namespace std;
//ctrl + k + d => выравнивание кода


int i02 = 1, j02 = 2, k02 = 3;

int main()
{
	setlocale(LC_ALL, "Russian");
	//УКАЗАТЕЛИ; операции & и *

	//переменная-указатель хранит адрес по которому размещаются данные (и они типпизированны те в них + инфа о типе данных, 
	//для которых они поределены (инфа о типе на этапе компиляции только существует, в памяти пк она не хрантится))
	int i = 1; float f = 10;
	int* pi;	//указатель на объект целого типа (умеет харнить только адресс целого типа данных)
	float* pf;	// указатель действительного типа

	pi = &i;	//& - адрессная операция  (возвращает адрес операнда (переменной i в данном случае))
	pf = &f;

	// * - операция разыменования (обращение по адресу в указателе (достаётся то, на что указан адрес))
	cout << "i= " << *pi << "; f= " << *pf << endl;

	// те pi = pf; pi = &f; pf = &i - ОШИБОЧНЫ (тк типизация другая)

	//ЛИШЬ указатель на пустой тип - это просто адрес, бех спецификации типа данных
	void* pv = pf;


	//обманка: заставим *pi указывать на весчественный тип .... что же будет?
	void* pv2 = pf;
	pi = (int*)pv2;
	cout << "?= " << *pi << "; f= " << *pf << endl;
	//показывает как это число float расположено в памяти 


	//можно определить указатель на указатель
	int i2 = 1;
	int* pi2 = &i2;			//int* - описание типа
	int** ppi2 = &pi2;		//int** - описание типа, хранит адрес на указатель на целый объект (хранит адрес на адрес на тип int)

	//обращение к i путём косвенной адресации:
	cout << "i= " << **ppi2 << endl;

	//приоритеты   <-----  ассоциативность (порядок выполнения операций с одинаковым приоритетом)
	//-  !  ~  ++i  --i  (type)  *  &  sizeof
	//**ppi = *(*ppi)     ***ppi = *(*(*ppi))  и тд


	cout << "									    " << endl;
	cout << "  ---------------------------------    " << endl;
	cout << "									    " << endl;



	//Указатели; Динамическая память
	//вся память разделена на статическую и динамическую
	// статическая - размещаются все переменные на этапе компиляции  (управляет компилятор)
	// (все переменные автомотически уничтожаются, когда выходят за пределы области видимости)
	// динамическая - (управляет программа) нужна, чтобы что-то пока нужно - работать с ним, а когда не нужно уже - удалить

	// new и delete - операции для динамического распределения памяти (введены в язык с++)
	// new - резервирование динамической памяти
	// delete - удаление динамической памяти 

	//А прога на Си использует функции библиотеки stdlib.h:     ( в С++ можно заменить на new и delete(даже НУЖНО))
	int* pi4 = (int*)malloc(sizeof(int)); // размещение
	free(pi4); // освобождение (удаление переменной)


	int* pi3 = new int; // размещение новой переменной типа int в динамической памяти и сохранение её адреса в указателе pi
	// new зарезервировал для хранения место в динамической памяти
	// а указатель pi в динамической памяти 
	//К ДИНАМИЧЕСКОЙ памяти можно обращаться только ЧЕРЕЗ УКАЗАТЕЛЬ, а к статической переменной можно там и по имени

	//   статическая память      |       динамическая память   
	//							 |
	//      pi: [*]----------------------->[      ]			
	//							 |

	*pi3 = 1; //по указателю теперь обращение к динамичекой переменной 

	float* pf3 = new float(10); // размещение переменной с инициализацией
	cout << "*pi3= " << *pi3 << "; *pf3 = " << *pf3 << endl;

	//   статическая память      |       динамическая память   
	//							 |
	//      pi3: [*]----------------------->[   1   ]			
	//							 |
	//      pf3: [*]----------------------->[  10.0 ]	
	//							 |
	//							 |

	// кста  к динамическим переменным можно образаться только указателями
	// так что надо чистить память

	delete pi3; delete pf3; // удаление динамических переменных в которых отпала необходимость   (в Си free)
	// а то сами же указатели лежат в  статической а потом мб область видимости их закончится, они потеряются а в динамической памяти
	//мусор продолжит лежать, так что надо его чистить. И теперь:

	//   статическая память      |       динамическая память   
	//							 |
	//      pi3: [*]-------X-------------->			
	//							 |
	//      pf3: [*]-------X-------------->	
	//							 |
	//							 |
	//те delete - удаляет динамическую память  (но адресс сохраняется)
	// !!!!!!!!!!!!!! кажой new ---- свой delete !!!!!!!!!!!  (статическое само удалится, как ненужно будет, а динамическое нет)
	// а то будет утечка памяти




	//					УКАЗАТЕЛИ И МАССИВЫ

	//указатели можно уменьшать и увеличивать на целое число (+ - ++ -- -= +=)
	//эти операции введены для эфективной работы с массивами. 
	//(увеличение указателя на 1 вызывает его перемещение на следующий эл массива)


	//приоритеты									 ассоциативность (порядок выполнения операций с одинаковым приоритетом)
	// ()  []  .   ->  i++  i--						 ----->
	//  -   !  ~  ++i  --i  (type)  *  &  sizeof     <-----


	//(но для начала....)    описание массивов:
	int a[10];				//определение массива из 10 целых эл
	//определение и инициализация массива:
	float b[] = { 1,2,3,4,5 };	// размер можно опустить


	// Индексная операция [] - для обращения к эл массива (это НЕ синтаксическая конструкция)
	for (i = 0; i < 10; i++) a[i] = i; // a[i] = i это выражение


	//операция sizeof(a) - возвращает размер массива в байтах
	for (i = 0; i < sizeof(a) / sizeof(int); i++) a[i] = i;
	// или
	for (i = 0; i < sizeof(a) / sizeof(a[0]); i++) a[i] = i;
	//              \						   /   sizeof(a) - те 10 * sizeof(int) ( sizeof(int) тоже в байтах)
	//				 ----------V--------------
	//                     кол-во эл


	//Имя массива - обозначает указатель на начало массива.
	if (a == &a[0])				//a==&a[0]   те можно удобно это юзать
		cout << "Индификатор массива можно использовать как указаель на его начало (адрес 0-го эл)" << endl;


	//Операции сравнения применимы к указателям. ПРАВИЛО сложения указателя с целым числом: 
	//изменение указателя на 1 вызывает изменение адреса в указателе на sizeof(типа данных)
	for (i = 0; i < sizeof(b) / sizeof(float); i++)
		cout << " " << *(b + i) << endl;	//это эквивалентно b[i] (индексная операция делается компилятором именно таким образом)

	//те    указатель += n <=>   адрес += n*sizeof(тип)
	// 
	// это работает тк все эл стоят друг за другом в памяти



	//Строковые константы - в памяти как массивы символов, с 0-вым байтом в конце
	char s[] = "0123456789";
	// s: [0][1][2][3][4][5][6][7][8][9]0      0 - это конец стр значит и этим можно пользоваться

	char* ps = s;	//	указатель на начало строки
	cout << *ps << endl;
	++ps;			//	переместили указатель на следующий эл
	cout << *ps << endl;
	ps += 4;		//сместили указатель на 4 эл
	cout << *ps << endl;

	cout << "                              " << endl;


	char* ps2 = s;
	// тк == 0 => false       а !=0 => true
	while (*ps2)			//те пока *ps!=0 (пока наш указатель не укажет на 0)
		cout << *ps2++;		//те  ==	*(ps++)  согласно приоритетам

	cout << "                              " << endl;

	while (ps2 > s)			//тк после прошло цикла наш ps2 в конце уже
		cout << *--ps2;		//те ==     *(--ps)  согласно ассоциативности

	cout << "                              " << endl;
	cout << "                              " << endl;




	//указатели можно вычитать и получать целочисленное смещение эл массива
	// 
	//указатель1 - указатель2 = (адрес1 - адрес2)/sizeof(тип)

	char s1[] = "0123456789", * ps3 = s; //  <==> char* ps3 = s;    тк char написан левее
	while (*ps3)
		ps3++;
	while (ps3 > s)		 //		сравнение указателей
		cout << *--ps3;

	cout << "                              " << endl;


	char* ps4 = s, * ps5 = s + 5;			//тк не забываем s == &s[0]
	cout << ps4 - ps5 << " " << ps5 - ps4;	//	-5 5




	cout << "                              " << endl;
	cout << "    Указатели и массивы                          " << endl;
	cout << "                              " << endl;

	//Указатели и массивы
	// ДИНАМИЧЕСКИЕ массивы  - в памяти хранятся примерно так, как и статические за исключением того, что они в динамической памяти лежат
	//Для размещения в памяти  и удаления  динамических массивов служат операции - new[] delete[]
	int* pm = new int[10];	//размещает в динамической памяти новый массив 10 целых чисел и сохраняет указатель на его начало в pm

	// Для обращения к эго эл можно юзать как индексную операцию, так и операции над указателями

	/*for (i = 0; i < sizeof(pm) / sizeof(int); i++) pm[i] = i;
	// sizeof(a) - возвращает размер массива в байтах(для статических),
	(не работает для динамических тк sizeof(pm) возвращает
	размер указателя на int, а не размер выделенного массива. Размер указателя на int обычно равен 4 или 8 байтам, в зависимости
	от архитектуры системы.)
	*/
	for (i = 0; i < sizeof(int) * 10 / sizeof(int); i++) pm[i] = i;
	for (i = 0; i < 10; i++) cout << "   " << *(pm + i);

	//   статическая память      |       динамическая память   
	//							 |
	//      pm: [*]--------------------->[0][1][2][3][4][5][6][7]			
	//							 |

	delete[] pm;// не забываем.Удаляет динамический массив

	//   статическая память      |       динамическая память   
	//							 |
	//      pm: [*]-------X-------------->			
	//							 |
	cout << endl;
	cout << "                              " << endl;



	//УКАЗАТЕЛИ И НЕ МАССИВЫ
	int i01 = 1, j01 = 2, k01 = 3;
	int* pi01 = &j01;
	++pi01;
	cout << *pi01 << endl;		//что же получим.....?
	// локальные переменные компелятор размещает в стековой памяти : i- самый старший адрес j-средний k-младший(те сверху)
	//те мб бы получили бы i, но оказалось что компилятор по другому размещает переменные видимо для оптимизации
	// делает какуе-то разрядку между переменными
	//можно даже командовать над разрядкой

	--pi01;
	cout << &i01 - pi01 << endl;		//смотрим на каком расстоянии находятся переменные друг от друга   -8 получилось
	pi01 -= 8;
	cout << *pi01 << endl;  // вывело 1 => всё норм это переменная i01
	pi01 += 8;
	pi01 += 8;
	cout << *pi01 << endl; // вывело 3 => это переменная k01
	//НО ЭТО рабоатет ТОЛЬКО для НАШЕГО компилятора, даже на др пк будет всё по другому

	//и кста с глобальными переменными мб компилятор по другому работает:
	int* pi02 = &j02;
	++pi02;
	cout << *pi02 << endl;			 // вывел 3 те k02
	cout << --(-- * pi02) << endl;	 // вывел 1 те k01




	//-------------------------------------------------------------------------------------------------------------------



	//	МАТРИЦЫ (двумерные массивы)
	//матрицы - массив массивов

	//в статической матрице нужно указывать размер обызательно
	float mat[4][10] = { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} }; 	//	4 массива в каждом из которых массив с 10 эл типа float
	//4 стр и 10 столбцов
	//40 эл
	// в данной матрице мы проинициализировали лишь 3*4 элементов матрицы,  а в остальных местах вообще не понятно что лежит


	int j = 0;//i была где-то вверху  в проге уже создана
	for (i = 0; i < 4; ++i)
	{
		for (j = 0; j < 4; ++j) cout << " " << mat[i][j];  // == (mat[i])[j]
		//тк mat == &mat[0]   и   указатель += n <=>   адрес += n*sizeof(тип)
		// 
		//	mat[i][j]: адресс mat + i*sizeof(mat[0]) + j * sizeof(тип)
		// 
		//	sizeof(mat[0]) = 10*sizeof(float) - размер строки   (нарощение адресса массива, для смещения к i-той стр)
		//	j*sizeof(float) - смещение в строке				  (смещение к j-ому элементу)
		cout << endl;
	}
	//mat[i][j]  ==  *(mat[i]+j)  ==  (*(mat+i))[j]  ==  *(*(mat+i)+j)    - это всё эквивалентно



	cout << "                              " << endl;
	cout << "                              " << endl;
	//старшую размерность можно опустить, но младшую указать обязательно!!!:
	//(чтобы компилятор знал, как смещаться к следующей строке по автоинкриментному способу)
	// а строк столько, сколько указали в инициализирующем выражении
	float matritsa[][10] = { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} };
	float* pf01;
	for (i = 0; i < 3; ++i)
	{
		for (j = 0, pf01 = matritsa[i]; j < 4; j++) cout << ' ' << *pf01++;
		//вычисляет указатель на начало очередной i-той строки
		cout << endl;
	}
	//так кста более эффективно
	//любая ИНДЕКСНАЯ операции МЕНЕЕ эффективна чем АВТОИНКРИМЕНТНАЯ



	cout << "                              " << endl;
	//МНОГОМЕРНЫЕ массивы - массивы массивов и тд
	//
	float matMnog[2][3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};	//верно написание
	//тк можно без скобок
	//те в 1 плоскости  {0, 1, 2, 3, 4}    {4, 5, 6, 7}  {8, 9, 10, 11}
	// во 2              ничего

	float matMnog2[][3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11 };
	float matMnog3[][3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11,12 };
	cout << sizeof(matMnog2) / sizeof(int) << endl;		//ответ будет 12 (те 12 эл)
	cout << sizeof(matMnog) / sizeof(int) << endl;		//ответ будет 24 (те 24 эл)
	cout << sizeof(matMnog3) / sizeof(int) << endl;		//ответ будет 24 (те 24 эл)

	//те НЕЛЬЗЯ опускать среднюю размерность , а опускать можно только страшую


	//-------------------------------------------------------------------------------------------------------------------


	//Матрицы и указатели
	//представление матрицы массивом указателей на одномерный массивы

	float matA[][4] = { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} };
	float* pmat[] = { matA[0],matA[1],matA[2] }; //одномерный массив указателей на одномерные массивы
	for (i = 0; i < 3; ++i)
	{
		for (j = 0; j < 4; ++j)cout << ' ' << pmat[i][j];	// ==   *(*(pmat+i)+j)
		//pmat[i][j] ==   выбрать[ адресс pmat + i * sizeof(тип * )] + j * sizeof(тип)
		//                       \               стр               /   \  столбец   /
		// (адресс pmat == pmat[0])
		cout << endl;
	}
	//те индексная операция при обращении непосредственно к массиву matA (обычному, статическому) ничем не
	//отличается от обращения к матрице из указателей на одномерный массив

	float c[] = { 12, 13,14,15 };
	float* pmat2[] = { matA[0],matA[1],matA[2],c }; //так тоже, конечно, можно
	cout << pmat2[3][3] << endl;   //15 выведет, тк индексы с 0 



	cout << "                              " << endl;
	cout << "                              " << endl;
	cout << "                              " << endl;


	//-------------------------------------------------------------------------------------------------------------------
	

	//ДИнамическая матрица (тк её размер меняется динамически и она сама целиком в динамической памяти)
	//можно и массив указателей на строки и сами строки матрицы разместить в динамической памяти
	float** e = new float* [4]; //размещаем массив указателей на строки-указатели

	for (int i = 0; i < 4; i++) e[i] = new float[3];  // (строка-указатель)размещаем массив указателей на эл строк матрицы

	//   статическая память      |       динамическая память   
	//							 |
	//      e: [*]----------------------->[][][][]
	//							 |        | | | |
	//							 |        | | | [][][]
	//							 |        | | [][][]
	//							 |        | [][][]
	//							 |        [][][]
	//							 |                        те 4 стр и 3 столбца

	//индексные операции кста работают всё также 
	for (int i = 0; i < 4; i++)
	{
		for (j = 0; j < 3; ++j) 
		{
			e[i][j] = 10 * i + j;	//e[i][j] == *(*(e+i)+j)  == *(*(&e[0]+i)+j)  == *([i]+j)
			cout << e[i][j]<<" ";
		}
		//* - операция разыменования (обращение по адресу в указателе (достаётся то, на что указан адрес))  (напоминаю)
		//&-адрессная операция(возвращает адрес операнда)
		cout << endl;

	}

	//удаление:
	for (int i = 0; i < 4; i++) delete[] e[i]; // удаляем строки матрицы
	//   статическая память      |       динамическая память   
	//							 |
	//      e: [*]----------------------->[][][][]
	//							 |        | | | x
	//							 |        | | x |
	//							 |        | x | 
	//							 |        x | 
	//							 |        | 
	//							 |        
	//							 |      
	delete[]e;     //удаляем массив указателей
	//   статическая память      |       динамическая память   
	//							 |
	//      e: [*]--------X-------------->
	//							 |        



	//-------------------------------------------------------------------------------------------------------------------

	//КСТА:
	float heh[] = { 1,2,3,4,5 };
	cout << heh[1, 2] << endl;			//Не ошибка, просто выведет эл на инексе 2 (те '3')

	// а вот:
	float heh2[4][10] = { {0,1,2,3}, {4,5,6,7}, {8,9,10,11} };
	cout << heh2[1, 2] << endl;			//выведет адрес 2(по индексу) строки   (а так третей вообще, если по русски)

	//-------------------------------------------------------------------------------------------------------------------
	cout << "                                                       " << endl;




	//						ФУНКЦИИ
	//Прога на си - это линейный набор функций (без вложеных описаний) в Си нельязя испольовать вложенные функции
	// а в С++ можно

	long maxik(long i1, long i2) {
		// тип возвращаемого значения   имя функции     (формальные переменные)

		if (i1 > i2) return i1;
			return i2;
	}


	cin.ignore();
	return 0;

}
